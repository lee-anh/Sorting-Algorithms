# Sorting-Algorithms

<h1>Introduction</h1>
The purpose of this project is to study how the theoretical analysis of sorting algorithms compares with their actual performance. The sorting algorithms explored in this project are selection sort, bubble sort, insertion sort, merge sort, and three versions of quicksort based on the choice of the pivot element (first, random, and median of three). Additional goals include comparing the sorting algorithms with one another, comparing implementations of merge sort and quicksort with the Java standard library’s implementations, and comparing the various versions of quicksort with one another. These goals will be accomplished by implementing the sorting algorithms, generating different arrays as test cases, running these test cases through the sorters, collecting the time that it takes for the algorithms to run on different sized and different types of arrays, and analyzing the data collected.

<h1>Results</h1>
In general, when the initial state of the arrays being sorted is not known, the best sorting algorithm out of the ones we implemented is merge sort. It was the most consistent because it was not vulnerable to the edge case of many duplicates and showed O(nlg(n)) runtime across the board. In contrast to quicksort, choosing a good pivot is not a concern, as the array is always split in the middle. Merge sort is also stable. The only major disadvantage is that it does take O(n) extra memory. However, memory space is becoming cheaper and cheaper as technology improves, diminishing the potential harmful effects of needed extra memory. 

If it is known that there will be few duplicates in the array, then in practice, quicksort random or quicksort median perform extremely well, also showing  O(nlg(n)) runtimes, and do not use any extra memory space. For quicksort first, the simplicity of just picking the first element as the pivot is greatly outweighed by the worst case performance in ascending and descending arrays. The major disadvantage for all the different implementations of quicksort is that there is always the possibility that a bad pivot may be chosen and thus the initial order of the arrays must be considered. It also is an unstable sorting algorithm.

Among the quadratic sorting algorithms of bubble sort, selection sort, and insertion sort, insertion sort is the best. Though it is dependent on the initial state of the array, its worst case is no worse than selection sort’s best, average, and worst cases. In line with that, the average and best cases of insertion sort perform better than the average and best cases of selection sort.  It is also a stable sorting algorithm whereas insertion sort is not. Selection sort is better than bubble sort though, which has extremely poor performance in most cases, with the exception of an already-sorted ascending array. However, this has very little practical value as there would be very few cases where someone would want to sort an already sorted array.

The only time that someone may want to use a quadratic sorting algorithm may be when the array size is very small (under 500 elements) because their implementation is simpler and would be less bug-prone. Other than that, using either merge sort or quicksort is almost always preferred.

If stable sorting is desired, then merge sort, insertion sort, or bubble sort can be used. Again, the best option would likely be merge sort for large arrays, insertion sort for small arrays, and almost never bubble sort. If stable sorting is not a concern, then quick sort or selection sort can be used. However, insertion sort still performs better than selection sort across the board, and merge sort tends to be more reliable than quicksort.

The most important knowledge we learned is that Big-Oh notation is really an approximation and an analysis of the general trend of a curve. There can be huge differences of about 1000 ms in the runtimes of algorithms that are all technically O(nlg(n)). Similarly, there can be huge differences in the runtimes of algorithms that are all technically O(n2). For example, bubble sort took around three times longer than the other quadratic sorting algorithms when sorting the same number of elements. Additionally, it would be best to use the Java standard library implementations of merge sort and quicksort in practice as these tend to outperform the user writing their own sorting algorithms. Although Java's implementations are more efficient, it is important to understand the analysis behind the benefits and drawbacks of these algorithms to make informed choices in software design. 


<h1>General Running Instructions</h1>
This project was created and should be run in BlueJ
